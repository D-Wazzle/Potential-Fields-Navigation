// PFCoordinateNav.c
// 
// Author: Dylan Wallace and Alvaro Pintado
// 
// This is an nxc program to use Potential Fields Navigation to plan a path around a group of static obstacles.
// This program will go toward using the NXT to navigate around dynamic obstacles that are tracked using ARToolkit.

#pragma config(Motor,  motorA,          A,             tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          B,             tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "timer.h"

// Track the estimated position & rotation of the robot
typedef struct
{
	int x;
	int y;
	int theta;
} Mobile;

void diffSteer(int xNext, int yNext, Mobile &mobile);

// Potential Field Constants & Data
//const float unitRad = 0.09411602;
const float unitDeg = 7.0;
const float wheelR = 1.0625;
const float baseR = 2.15625;
const float T = 0.1;
const float rho0[] = { 9000000, 9000000, 9000000, 9000000 };
//const float rho0[] = { 10, 10, 10 };
const float nAttract = 0.95;
const float nRepulse[] = { 9000000, 9000000, 9000000, 9000000 };
//const float nRepulse[] = { 0, 0, 0 };
const int xObstacle[] = { 120, 210, 240, 300 };
const int yObstacle[] = { 30, 120, 60, 120 };
const int xTarget = 390;
const int yTarget = 180;

task main()
{
  float rho[4];
	float ur_x[4];
	float ur_y[4];
	int xNext;
	int yNext;
  	Mobile mobile;
  	mobile.x = 0;
	mobile.y = 0;
	mobile.theta = 90;
	int i, j;

	// Potential Field Calculations
	for (i = 2; i < 1001; i++) // Run algorithm for 1000 sample periods
	{
		// Distance to an obstacle (Eqn 8)
		for (j = 0; j < 4; j++)
		{
			rho[j] = sqrt( pow((yObstacle[j]-mobile.y), 2) + pow((xObstacle[j]-mobile.x), 2) );

			// Calculate gradient (Eqns 11 and 13)
			if (rho[j] < rho0[j])
			{
				ur_x[j] = nRepulse[j]*(xObstacle[j]-mobile.x)*((1/rho[j])-(1/rho0[j]))/pow(rho[j], 3);
				ur_y[j] = nRepulse[j]*(yObstacle[j]-mobile.y)*((1/rho[j])-(1/rho0[j]))/pow(rho[j], 3);
			}

			else
			{
				ur_x[j] = 0;
				ur_y[j] = 0;
			}

		}
		//TextOut(0, LCD_LINE2, "Rho[0]: "); NumOut(45, LCD_LINE2, rho[0]);
		//TextOut(0, LCD_LINE3, "Ur_X[0]: "); NumOut(50, LCD_LINE3, ur_x[0]);
    		//TextOut(0, LCD_LINE4, "Ur_Y[0]: "); NumOut(50, LCD_LINE4, ur_y[0]);
		//displayString(7, "rho[0]: %f", rho[0]);

		displayString(0, "X: %d", mobile.x);
    		displayString(1, "Y: %d", mobile.y);

		// Calculate new robot position (Eqns 15 and 16)
		xNext = mobile.x - (T*nAttract*(mobile.x-xTarget))-(T*ur_x[0])-(T*ur_x[1])-(T*ur_x[2])-(T*ur_x[3]);
		yNext = mobile.y - (T*nAttract*(mobile.y-yTarget))-(T*ur_y[0])-(T*ur_y[1])-(T*ur_y[2])-(T*ur_y[3]);
		displayString(2, "xNext: %d", xNext);
    		displayString(3, "yNext: %d", yNext);

    		diffSteer(xNext, yNext, mobile);

    		if((xNext == mobile.x) && (yNext == mobile.y))
		{
				motor[motorA] = 0;
				motor[motorB] = 0;
		}

    		mobile.x = xNext;
    		mobile.y = yNext;

		wait1Msec(30);
		eraseDisplay();
	}
}

void diffSteer(int xNext, int yNext, Mobile &mobile)
{
	// Adjust the direction and and next position of the robot
	
	float r = sqrt(pow((xNext - mobile.x), 2) + pow((yNext - mobile.y), 2));
	displayString(4, "r: %.2f", r);

	float thetaTarget = ((PI/2) - atan2((xNext-mobile.x), (yNext-mobile.y)))*(180/PI);
	displayString(5, "thetaT: %.2f", thetaTarget);
	int deltaTheta = thetaTarget - mobile.theta;
	displayString(6, "Dtheta: %d", deltaTheta);

	if(deltaTheta < 0)
	{
		int wheelTheta = -1*deltaTheta*(baseR/wheelR);
		displayString(7, "wTheta: %d", wheelTheta);
		nSyncedMotors = synchBA;
		nSyncedTurnRatio = -100;
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = wheelTheta;

		while((nMotorEncoder[motorB] < wheelTheta) && (wheelTheta > 0))
		{
			motor[motorB] = 15;
		}

		motor[motorB] = 0;
		mobile.theta = thetaTarget;
	}

	else if(deltaTheta > 0)
	{
		int wheelTheta = deltaTheta*(baseR/wheelR);
		displayString(7, "wTheta: %d", wheelTheta);
		nSyncedMotors = synchAB;
		nSyncedTurnRatio = -100;
		nMotorEncoder[motorA] = 0;
		nMotorEncoderTarget[motorA] = wheelTheta;

		while((nMotorEncoder[motorA] < wheelTheta) && (wheelTheta > 0))
		{
			motor[motorA] = 15;
		}

		motor[motorA] = 0;
		mobile.theta = thetaTarget;
	}

	wait1Msec(100);

	r = (r*unitDeg)/2;
	nSyncedMotors = synchNone;
	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorA] = r;
	nMotorEncoderTarget[motorB] = r;

	while(nMotorEncoder[motorB] < r && r > 0)
	{
		if((xNext == mobile.x) && (yNext == mobile.y))
		{
			motor[motorA] = 0;
			motor[motorB] = 0;
		}

		else
		{
			motor[motorA] = 20;
			motor[motorB] = 20;
		}
	}
}
